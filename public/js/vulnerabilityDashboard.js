/**
 * Vulnerability Dashboard UI Components
 * Provides visualization and interaction for vulnerabilities from Rapid7
 */

document.addEventListener('DOMContentLoaded', function() {
  initVulnerabilityDashboard();
  setupVulnEventListeners();
});

/**
 * Initialize vulnerability dashboard components
 */
function initVulnerabilityDashboard() {
  // Initialize vulnerability severity chart if present
  const vulnSeverityChart = document.getElementById('vulnerabilitySeverityChart');
  if (vulnSeverityChart) {
    initializeVulnSeverityChart();
  }
  
  // Initialize scan history chart if present
  const scanHistoryChart = document.getElementById('scanHistoryChart');
  if (scanHistoryChart) {
    initializeScanHistoryChart();
  }
  
  // Initialize top vulnerabilities table if present
  const topVulnsTable = document.getElementById('topVulnerabilitiesTable');
  if (topVulnsTable) {
    loadTopVulnerabilities();
  }
  
  // Load vulnerability summary stats
  loadVulnerabilitySummary();
}

/**
 * Setup event listeners for vulnerability UI
 */
function setupVulnEventListeners() {
  // Project filter for vulnerabilities
  const vulnProjectFilter = document.getElementById('vulnProjectFilter');
  if (vulnProjectFilter) {
    vulnProjectFilter.addEventListener('change', function() {
      filterVulnerabilities(this.value);
    });
  }
  
  // Refresh vulnerability data button
  const refreshVulnBtn = document.getElementById('refreshVulnBtn');
  if (refreshVulnBtn) {
    refreshVulnBtn.addEventListener('click', function() {
      refreshVulnerabilityData();
    });
  }
  
  // New scan button
  const newScanBtn = document.getElementById('startScanBtn');
  if (newScanBtn) {
    newScanBtn.addEventListener('click', function() {
      showScanConfigModal();
    });
  }
  
  // Setup vulnerability linking modal events
  setupVulnLinkingHandlers();
}

/**
 * Initialize vulnerability severity chart
 */
function initializeVulnSeverityChart() {
  fetch('/api/vulnerabilities/stats/overview')
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        renderVulnSeverityChart(data.data);
      } else {
        showVulnError('Failed to load vulnerability statistics');
      }
    })
    .catch(error => {
      console.error('Error loading vulnerability statistics:', error);
      showVulnError('Error loading vulnerability statistics');
    });
}

/**
 * Render vulnerability severity chart
 */
function renderVulnSeverityChart(vulnData) {
  const ctx = document.getElementById('vulnerabilitySeverityChart');
  if (!ctx) return;
  
  // Process data for the chart
  const severities = Object.keys(vulnData.by_severity);
  const totalVulns = severities.map(sev => vulnData.by_severity[sev].total);
  const openVulns = severities.map(sev => vulnData.by_severity[sev].open);
  const fixedVulns = severities.map(sev => vulnData.by_severity[sev].fixed);
  
  // Create the stacked bar chart
  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: severities,
      datasets: [
        {
          label: 'Open',
          data: openVulns,
          backgroundColor: 'rgba(255, 99, 132, 0.7)',
          borderColor: 'rgba(255, 99, 132, 1)',
          borderWidth: 1
        },
        {
          label: 'Fixed',
          data: fixedVulns,
          backgroundColor: 'rgba(75, 192, 192, 0.7)',
          borderColor: 'rgba(75, 192, 192, 1)',
          borderWidth: 1
        },
        {
          label: 'In Progress',
          data: severities.map(sev => vulnData.by_severity[sev].in_progress),
          backgroundColor: 'rgba(255, 206, 86, 0.7)',
          borderColor: 'rgba(255, 206, 86, 1)',
          borderWidth: 1
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          title: {
            display: true,
            text: 'Severity'
          }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          title: {
            display: true,
            text: 'Count'
          }
        }
      },
      plugins: {
        title: {
          display: true,
          text: 'Vulnerabilities by Severity and Status'
        },
        tooltip: {
          mode: 'index',
          intersect: false
        }
      }
    }
  });
  
  // Update summary statistics
  updateVulnSummaryStats(vulnData);
}

/**
 * Update vulnerability summary statistics
 */
function updateVulnSummaryStats(vulnData) {
  document.getElementById('totalVulnCount')?.textContent = vulnData.total || 0;
  document.getElementById('openVulnCount')?.textContent = vulnData.open || 0;
  document.getElementById('fixedVulnCount')?.textContent = vulnData.fixed || 0;
  document.getElementById('inProgressVulnCount')?.textContent = vulnData.in_progress || 0;
  
  // Calculate percentage fixed
  const percentFixed = vulnData.total > 0 
    ? Math.round((vulnData.fixed / vulnData.total) * 100) 
    : 0;
  
  const fixedProgressBar = document.getElementById('fixedProgressBar');
  if (fixedProgressBar) {
    fixedProgressBar.style.width = `${percentFixed}%`;
    fixedProgressBar.setAttribute('aria-valuenow', percentFixed);
    fixedProgressBar.textContent = `${percentFixed}%`;
  }
}

/**
 * Initialize scan history chart
 */
function initializeScanHistoryChart() {
  fetch('/api/rapid7/scan-history/stats')
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        renderScanHistoryChart(data.data);
      } else {
        showVulnError('Failed to load scan history');
      }
    })
    .catch(error => {
      console.error('Error loading scan history:', error);
      showVulnError('Error loading scan history');
    });
}

/**
 * Render scan history chart
 */
function renderScanHistoryChart(scanData) {
  const ctx = document.getElementById('scanHistoryChart');
  if (!ctx) return;
  
  // Get data for Rapid7 source (or the first source available)
  const sourceKey = 'rapid7' in scanData ? 'rapid7' : Object.keys(scanData)[0];
  if (!sourceKey) return;
  
  const source = scanData[sourceKey];
  
  // Create line chart showing vulnerability trends
  // For this example, we're using mock time series data
  // In production, you would fetch actual time series data
  
  // Mock data - replace with actual API call in production
  const mockDates = [];
  const mockVulnCounts = [];
  
  // Generate 6 months of mock data
  const now = new Date();
  for (let i = 5; i >= 0; i--) {
    const date = new Date(now);
    date.setMonth(now.getMonth() - i);
    mockDates.push(date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }));
    
    // Start with source.total_vulnerabilities and decrease as we go back in time
    const factor = 1 - (i * 0.15);  // 15% decrease per month going backward
    mockVulnCounts.push(Math.round(source.total_vulnerabilities * factor));
  }
  
  // Create the chart
  new Chart(ctx, {
    type: 'line',
    data: {
      labels: mockDates,
      datasets: [{
        label: 'Vulnerabilities Found',
        data: mockVulnCounts,
        borderColor: 'rgba(255, 99, 132, 1)',
        backgroundColor: 'rgba(255, 99, 132, 0.1)',
        borderWidth: 2,
        tension: 0.3,
        fill: true
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: 'Vulnerability Count'
          }
        },
        x: {
          title: {
            display: true,
            text: 'Month'
          }
        }
      },
      plugins: {
        title: {
          display: true,
          text: 'Vulnerability Trend Over Time'
        }
      }
    }
  });
  
  // Update scan summary statistics
  updateScanSummaryStats(source);
}

/**
 * Update scan summary statistics
 */
function updateScanSummaryStats(scanData) {
  document.getElementById('totalScansCount')?.textContent = scanData.total_scans || 0;
  document.getElementById('completedScansCount')?.textContent = scanData.completed_scans || 0;
  document.getElementById('avgVulnerabilitiesPerScan')?.textContent = scanData.avg_vulnerabilities_per_scan || 0;
  
  // Format last scan date
  if (scanData.last_completed_scan) {
    const lastScanDate = new Date(scanData.last_completed_scan);
    document.getElementById('lastScanDate')?.textContent = 
      lastScanDate.toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
  } else {
    document.getElementById('lastScanDate')?.textContent = 'No scans completed';
  }
}

/**
 * Load top vulnerabilities table
 */
function loadTopVulnerabilities() {
  fetch('/api/vulnerabilities?severity=Critical,High&limit=10')
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        renderTopVulnerabilitiesTable(data.data);
      } else {
        showVulnError('Failed to load top vulnerabilities');
      }
    })
    .catch(error => {
      console.error('Error loading top vulnerabilities:', error);
      showVulnError('Error loading top vulnerabilities');
    });
}

/**
 * Render top vulnerabilities table
 */
function renderTopVulnerabilitiesTable(vulnerabilities) {
  const tableBody = document.querySelector('#topVulnerabilitiesTable tbody');
  if (!tableBody) return;
  
  // Clear existing table rows
  tableBody.innerHTML = '';
  
  if (vulnerabilities.length === 0) {
    const emptyRow = document.createElement('tr');
    emptyRow.innerHTML = '<td colspan="5" class="text-center">No vulnerabilities found</td>';
    tableBody.appendChild(emptyRow);
    return;
  }
  
  // Add vulnerability rows
  vulnerabilities.forEach(vuln => {
    const row = document.createElement('tr');
    
    // Set row class based on severity
    if (vuln.severity === 'Critical') {
      row.className = 'table-danger';
    } else if (vuln.severity === 'High') {
      row.className = 'table-warning';
    }
    
    row.innerHTML = `
      <td>${escapeHtml(vuln.name)}</td>
      <td>${vuln.severity}</td>
      <td>${vuln.cvss_score || 'N/A'}</td>
      <td>${vuln.status}</td>
      <td>
        <button class="btn btn-sm btn-primary view-vuln-btn" data-vuln-id="${vuln.id}">
          View
        </button>
        <button class="btn btn-sm btn-success link-vuln-btn" data-vuln-id="${vuln.id}" data-vuln-name="${escapeHtml(vuln.name)}">
          Link to Threat
        </button>
      </td>
    `;
    
    tableBody.appendChild(row);
  });
  
  // Add click handlers for buttons
  tableBody.querySelectorAll('.view-vuln-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      const vulnId = this.getAttribute('data-vuln-id');
      viewVulnerabilityDetails(vulnId);
    });
  });
  
  tableBody.querySelectorAll('.link-vuln-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      const vulnId = this.getAttribute('data-vuln-id');
      const vulnName = this.getAttribute('data-vuln-name');
      showLinkVulnerabilityModal(vulnId, vulnName);
    });
  });
}

/**
 * Setup vulnerability linking handlers
 */
function setupVulnLinkingHandlers() {
  // Link vulnerability form submission
  const linkVulnForm = document.getElementById('linkVulnerabilityForm');
  if (linkVulnForm) {
    linkVulnForm.addEventListener('submit', function(e) {
      e.preventDefault();
      linkVulnerabilityToThreat();
    });
  }
}

/**
 * Link vulnerability to threat
 */
function linkVulnerabilityToThreat() {
  const vulnId = document.getElementById('linkVulnId').value;
  const threatId = document.getElementById('threatSelector').value;
  const confidence = document.getElementById('confidenceSlider').value;
  const notes = document.getElementById('linkingNotes').value;
  
  if (!vulnId || !threatId) {
    showVulnError('Vulnerability ID and Threat ID are required');
    return;
  }
  
  const linkData = {
    threat_id: threatId,
    match_confidence: confidence,
    notes: notes
  };
  
  fetch(`/api/vulnerabilities/${vulnId}/threats`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(linkData)
  })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        // Close the modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('linkVulnerabilityModal'));
        modal.hide();
        
        showVulnSuccess('Vulnerability successfully linked to threat');
        
        // Optionally refresh any affected data displays
        if (document.getElementById('topVulnerabilitiesTable')) {
          loadTopVulnerabilities();
        }
      } else {
        showVulnError(data.error || 'Failed to link vulnerability to threat');
      }
    })
    .catch(error => {
      console.error('Error linking vulnerability to threat:', error);
      showVulnError('Error linking vulnerability to threat');
    });
}

/**
 * Show vulnerability details modal
 */
function viewVulnerabilityDetails(vulnId) {
  fetch(`/api/vulnerabilities/${vulnId}`)
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        showVulnerabilityModal(data.data);
      } else {
        showVulnError('Failed to load vulnerability details');
      }
    })
    .catch(error => {
      console.error('Error loading vulnerability details:', error);
      showVulnError('Error loading vulnerability details');
    });
}

/**
 * Show vulnerability details in a modal
 */
function showVulnerabilityModal(vuln) {
  const modalTitle = document.querySelector('#vulnerabilityDetailsModal .modal-title');
  const modalBody = document.querySelector('#vulnerabilityDetailsModal .modal-body');
  
  if (!modalTitle || !modalBody) return;
  
  modalTitle.textContent = vuln.name;
  
  // Format vulnerability details
  modalBody.innerHTML = `
    <div class="row mb-3">
      <div class="col-md-6">
        <h5>Severity</h5>
        <span class="badge bg-${getSeverityBadgeClass(vuln.severity)}">${vuln.severity}</span>
      </div>
      <div class="col-md-6">
        <h5>CVSS Score</h5>
        <span>${vuln.cvss_score || 'N/A'}</span>
      </div>
    </div>
    
    <div class="row mb-3">
      <div class="col-md-6">
        <h5>Status</h5>
        <span class="badge bg-${getStatusBadgeClass(vuln.status)}">${vuln.status}</span>
      </div>
      <div class="col-md-6">
        <h5>CVE</h5>
        <span>${vuln.cve_id || 'N/A'}</span>
      </div>
    </div>
    
    <div class="mb-3">
      <h5>Description</h5>
      <p>${vuln.description || 'No description available'}</p>
    </div>
    
    <div class="mb-3">
      <h5>Remediation Steps</h5>
      <p>${vuln.remediation_steps || 'No remediation steps available'}</p>
    </div>
    
    <hr>
    
    <div class="mb-3">
      <h5>Related Threats</h5>
      <div id="relatedThreatsContainer">
        ${formatRelatedThreats(vuln.related_threats)}
      </div>
    </div>
  `;
  
  // Show the modal
  const modal = new bootstrap.Modal(document.getElementById('vulnerabilityDetailsModal'));
  modal.show();
}

/**
 * Format related threats HTML
 */
function formatRelatedThreats(threats) {
  if (!threats || threats.length === 0) {
    return '<p>No related threats found</p>';
  }
  
  let html = '<div class="list-group">';
  
  threats.forEach(threat => {
    html += `
      <div class="list-group-item">
        <div class="d-flex w-100 justify-content-between">
          <h6 class="mb-1">${escapeHtml(threat.name)}</h6>
          <small class="text-muted">Match: ${threat.match_confidence}%</small>
        </div>
        <p class="mb-1">${escapeHtml(threat.threat_model_name || '')}</p>
        <small>${escapeHtml(threat.category || '')}</small>
      </div>
    `;
  });
  
  html += '</div>';
  return html;
}

/**
 * Show link vulnerability modal
 */
function showLinkVulnerabilityModal(vulnId, vulnName) {
  document.getElementById('linkVulnId').value = vulnId;
  document.getElementById('linkVulnName').textContent = vulnName;
  
  // Load threats for the dropdown
  loadThreatsForDropdown();
  
  // Show the modal
  const modal = new bootstrap.Modal(document.getElementById('linkVulnerabilityModal'));
  modal.show();
}

/**
 * Load threats for the dropdown
 */
function loadThreatsForDropdown() {
  fetch('/api/threats')
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        populateThreatsDropdown(data.data);
      } else {
        showVulnError('Failed to load threats');
      }
    })
    .catch(error => {
      console.error('Error loading threats:', error);
      showVulnError('Error loading threats');
    });
}

/**
 * Populate threats dropdown
 */
function populateThreatsDropdown(threats) {
  const dropdown = document.getElementById('threatSelector');
  if (!dropdown) return;
  
  // Clear existing options
  dropdown.innerHTML = '<option value="">Select a threat...</option>';
  
  // Sort threats by model and name
  threats.sort((a, b) => {
    if (a.threat_model_id !== b.threat_model_id) {
      return a.threat_model_id.localeCompare(b.threat_model_id);
    }
    return a.name.localeCompare(b.name);
  });
  
  // Group threats by threat model
  const threatGroups = {};
  
  threats.forEach(threat => {
    if (!threatGroups[threat.threat_model_id]) {
      threatGroups[threat.threat_model_id] = [];
    }
    threatGroups[threat.threat_model_id].push(threat);
  });
  
  // Add options with optgroups
  Object.keys(threatGroups).forEach(modelId => {
    const group = document.createElement('optgroup');
    group.label = `Model: ${modelId}`;
    
    threatGroups[modelId].forEach(threat => {
      const option = document.createElement('option');
      option.value = threat.id;
      option.textContent = threat.name;
      group.appendChild(option);
    });
    
    dropdown.appendChild(group);
  });
}

/**
 * Refresh vulnerability data
 */
function refreshVulnerabilityData() {
  // Refresh all vulnerability visualizations
  initializeVulnSeverityChart();
  initializeScanHistoryChart();
  loadTopVulnerabilities();
  
  showVulnSuccess('Vulnerability data refreshed');
}

/**
 * Filter vulnerabilities by project
 */
function filterVulnerabilities(projectId) {
  // Implementation will depend on UI structure
  console.log(`Filtering vulnerabilities for project: ${projectId}`);
  
  // Update the UI components with filtered data
  // This would typically involve API calls with the projectId as a filter parameter
}

/**
 * Show error message for vulnerability dashboard
 */
function showVulnError(message) {
  const errorContainer = document.getElementById('vulnAlertContainer');
  if (!errorContainer) return;
  
  const alertDiv = document.createElement('div');
  alertDiv.className = 'alert alert-danger alert-dismissible fade show';
  alertDiv.setAttribute('role', 'alert');
  
  alertDiv.innerHTML = `
    ${message}
    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
  `;
  
  errorContainer.appendChild(alertDiv);
  
  // Auto-dismiss after 5 seconds
  setTimeout(() => {
    const alert = new bootstrap.Alert(alertDiv);
    alert.close();
  }, 5000);
}

/**
 * Show success message for vulnerability dashboard
 */
function showVulnSuccess(message) {
  const alertContainer = document.getElementById('vulnAlertContainer');
  if (!alertContainer) return;
  
  const alertDiv = document.createElement('div');
  alertDiv.className = 'alert alert-success alert-dismissible fade show';
  alertDiv.setAttribute('role', 'alert');
  
  alertDiv.innerHTML = `
    ${message}
    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
  `;
  
  alertContainer.appendChild(alertDiv);
  
  // Auto-dismiss after 5 seconds
  setTimeout(() => {
    const alert = new bootstrap.Alert(alertDiv);
    alert.close();
  }, 5000);
}

/**
 * Get badge class for severity
 */
function getSeverityBadgeClass(severity) {
  switch (severity) {
    case 'Critical': return 'danger';
    case 'High': return 'warning';
    case 'Medium': return 'primary';
    case 'Low': return 'success';
    default: return 'secondary';
  }
}

/**
 * Get badge class for status
 */
function getStatusBadgeClass(status) {
  switch (status) {
    case 'Open': return 'danger';
    case 'In Progress': return 'warning';
    case 'Fixed': return 'success';
    default: return 'secondary';
  }
}

/**
 * Helper function to escape HTML
 */
function escapeHtml(unsafe) {
  return unsafe
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

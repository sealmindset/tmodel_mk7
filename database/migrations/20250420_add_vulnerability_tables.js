/**
 * Migration: Add Vulnerability Tables
 * 
 * This migration adds the necessary tables and columns for the Rapid7 vulnerability integration
 */

const { Pool } = require('pg');
const pool = new Pool({
  host: process.env.PGHOST || 'localhost',
  port: process.env.PGPORT || 5432,
  database: process.env.PGDATABASE || 'postgres',
  user: process.env.PGUSER || 'postgres',
  password: process.env.PGPASSWORD || 'postgres'
});

async function up() {
  const client = await pool.connect();
  try {
    // Start transaction
    await client.query('BEGIN');

    // Check if cvss_score column exists in vulnerabilities table
    const columnCheckResult = await client.query(`
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_schema = 'threat_model' 
      AND table_name = 'vulnerabilities' 
      AND column_name = 'cvss_score'
    `);

    // Add cvss_score column if it doesn't exist
    if (columnCheckResult.rows.length === 0) {
      console.log('Adding cvss_score column to vulnerabilities table');
      await client.query(`
        ALTER TABLE threat_model.vulnerabilities
        ADD COLUMN cvss_score NUMERIC(3,1)
      `);
    }

    // Check if scan_history table exists
    const tableCheckResult = await client.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'threat_model' 
      AND table_name = 'scan_history'
    `);

    // Create scan_history table if it doesn't exist
    if (tableCheckResult.rows.length === 0) {
      console.log('Creating scan_history table');
      await client.query(`
        CREATE TABLE threat_model.scan_history (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          project_id UUID REFERENCES threat_model.projects(id) ON DELETE CASCADE,
          scan_type VARCHAR(50) NOT NULL,
          status VARCHAR(50) NOT NULL DEFAULT 'Pending',
          start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          end_time TIMESTAMP WITH TIME ZONE,
          vulnerabilities_found INTEGER DEFAULT 0,
          vulnerabilities_fixed INTEGER DEFAULT 0,
          scan_report JSONB,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )
      `);
    }

    // Check if vulnerability_history table exists
    const historyTableCheckResult = await client.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'threat_model' 
      AND table_name = 'vulnerability_history'
    `);

    // Create vulnerability_history table if it doesn't exist
    if (historyTableCheckResult.rows.length === 0) {
      console.log('Creating vulnerability_history table');
      await client.query(`
        CREATE TABLE threat_model.vulnerability_history (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          vulnerability_id UUID REFERENCES threat_model.vulnerabilities(id) ON DELETE CASCADE,
          status VARCHAR(50) NOT NULL,
          notes TEXT,
          updated_by VARCHAR(100),
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )
      `);
    }

    // Add last_vulnerability_sync column to projects table if it doesn't exist
    const syncColumnCheckResult = await client.query(`
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_schema = 'threat_model' 
      AND table_name = 'projects' 
      AND column_name = 'last_vulnerability_sync'
    `);

    if (syncColumnCheckResult.rows.length === 0) {
      console.log('Adding last_vulnerability_sync column to projects table');
      await client.query(`
        ALTER TABLE threat_model.projects
        ADD COLUMN last_vulnerability_sync TIMESTAMP WITH TIME ZONE
      `);
    }

    // Commit transaction
    await client.query('COMMIT');
    console.log('Migration completed successfully');
  } catch (error) {
    // Rollback transaction on error
    await client.query('ROLLBACK');
    console.error('Migration failed:', error);
    throw error;
  } finally {
    client.release();
  }
}

async function down() {
  const client = await pool.connect();
  try {
    // Start transaction
    await client.query('BEGIN');

    // Drop vulnerability_history table
    await client.query(`
      DROP TABLE IF EXISTS threat_model.vulnerability_history
    `);

    // Drop scan_history table
    await client.query(`
      DROP TABLE IF EXISTS threat_model.scan_history
    `);

    // Remove cvss_score column from vulnerabilities table
    await client.query(`
      ALTER TABLE threat_model.vulnerabilities
      DROP COLUMN IF EXISTS cvss_score
    `);

    // Remove last_vulnerability_sync column from projects table
    await client.query(`
      ALTER TABLE threat_model.projects
      DROP COLUMN IF EXISTS last_vulnerability_sync
    `);

    // Commit transaction
    await client.query('COMMIT');
    console.log('Rollback completed successfully');
  } catch (error) {
    // Rollback transaction on error
    await client.query('ROLLBACK');
    console.error('Rollback failed:', error);
    throw error;
  } finally {
    client.release();
  }
}

module.exports = {
  up,
  down
};

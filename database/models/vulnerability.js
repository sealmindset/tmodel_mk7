/**
 * Vulnerability Model
 * 
 * Provides data access methods for vulnerabilities imported from Rapid7 or other scanning tools
 */
const db = require('../index');

class Vulnerability {
  /**
   * Create a new vulnerability
   * 
   * @param {Object} vulnerabilityData - Vulnerability data
   * @returns {Promise<Object>} - Created vulnerability
   */
  static async create(vulnerabilityData) {
    const { 
      external_id, 
      source, 
      name, 
      description, 
      component_id, 
      severity, 
      cvss_score,
      cve_id,
      status = 'Open',
      remediation_steps,
      discovered_at,
      last_checked
    } = vulnerabilityData;
    
    const query = `
      INSERT INTO threat_model.vulnerabilities 
        (external_id, source, name, description, component_id, severity, 
         cvss_score, cve_id, status, remediation_steps, discovered_at, last_checked)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
      RETURNING *
    `;
    
    const values = [
      external_id, 
      source, 
      name, 
      description, 
      component_id, 
      severity, 
      cvss_score,
      cve_id,
      status,
      remediation_steps,
      discovered_at || new Date(),
      last_checked || new Date()
    ];
    
    const result = await db.query(query, values);
    return result.rows[0];
  }
  
  /**
   * Get vulnerability by ID
   * 
   * @param {string} id - Vulnerability ID
   * @returns {Promise<Object>} - Vulnerability data
   */
  static async getById(id) {
    const query = 'SELECT * FROM threat_model.vulnerabilities WHERE id = $1';
    const result = await db.query(query, [id]);
    return result.rows[0];
  }
  
  /**
   * Get vulnerability by external ID
   * 
   * @param {string} externalId - External Vulnerability ID (e.g. Rapid7 ID)
   * @param {string} source - Source system (e.g., 'rapid7')
   * @returns {Promise<Object>} - Vulnerability data
   */
  static async getByExternalId(externalId, source) {
    const query = 'SELECT * FROM threat_model.vulnerabilities WHERE external_id = $1 AND source = $2';
    const result = await db.query(query, [externalId, source]);
    return result.rows[0];
  }
  
  /**
   * Get all vulnerabilities
   * 
   * @param {Object} filters - Optional filters
   * @returns {Promise<Array>} - Array of vulnerabilities
   */
  static async getAll(filters = {}) {
    const { source, severity, status, component_id, cve_id } = filters;
    let query = 'SELECT * FROM threat_model.vulnerabilities';
    const values = [];
    
    // Add filters if provided
    const conditions = [];
    if (source) {
      conditions.push(`source = $${values.length + 1}`);
      values.push(source);
    }
    
    if (severity) {
      conditions.push(`severity = $${values.length + 1}`);
      values.push(severity);
    }
    
    if (status) {
      conditions.push(`status = $${values.length + 1}`);
      values.push(status);
    }
    
    if (component_id) {
      conditions.push(`component_id = $${values.length + 1}`);
      values.push(component_id);
    }
    
    if (cve_id) {
      conditions.push(`cve_id = $${values.length + 1}`);
      values.push(cve_id);
    }
    
    if (conditions.length > 0) {
      query += ' WHERE ' + conditions.join(' AND ');
    }
    
    query += ' ORDER BY severity, discovered_at DESC';
    
    const result = await db.query(query, values);
    return result.rows;
  }
  
  /**
   * Update a vulnerability
   * 
   * @param {string} id - Vulnerability ID
   * @param {Object} vulnerabilityData - Vulnerability data to update
   * @returns {Promise<Object>} - Updated vulnerability
   */
  static async update(id, vulnerabilityData) {
    const { 
      name, 
      description, 
      component_id, 
      severity, 
      cvss_score,
      cve_id,
      status,
      remediation_steps,
      last_checked
    } = vulnerabilityData;
    
    const query = `
      UPDATE threat_model.vulnerabilities
      SET 
        name = $1,
        description = $2,
        component_id = $3,
        severity = $4,
        cvss_score = $5,
        cve_id = $6,
        status = $7,
        remediation_steps = $8,
        last_checked = $9,
        updated_at = CURRENT_TIMESTAMP
      WHERE id = $10
      RETURNING *
    `;
    
    const values = [
      name, 
      description, 
      component_id, 
      severity, 
      cvss_score,
      cve_id,
      status,
      remediation_steps,
      last_checked || new Date(),
      id
    ];
    
    const result = await db.query(query, values);
    return result.rows[0];
  }
  
  /**
   * Delete a vulnerability
   * 
   * @param {string} id - Vulnerability ID
   * @returns {Promise<boolean>} - True if deleted
   */
  static async delete(id) {
    const query = 'DELETE FROM threat_model.vulnerabilities WHERE id = $1';
    const result = await db.query(query, [id]);
    return result.rowCount > 0;
  }
  
  /**
   * Get related threats for a vulnerability
   * 
   * @param {string} vulnerabilityId - Vulnerability ID
   * @returns {Promise<Array>} - Related threats
   */
  static async getRelatedThreats(vulnerabilityId) {
    const query = `
      SELECT t.*, tm.name as threat_model_name, tv.match_confidence
      FROM threat_model.threats t
      JOIN threat_model.threat_models tm ON t.threat_model_id = tm.id
      JOIN threat_model.threat_vulnerabilities tv ON t.id = tv.threat_id
      WHERE tv.vulnerability_id = $1
      ORDER BY tv.match_confidence DESC
    `;
    
    const result = await db.query(query, [vulnerabilityId]);
    return result.rows;
  }
  
  /**
   * Link vulnerability to a threat
   * 
   * @param {string} vulnerabilityId - Vulnerability ID
   * @param {string} threatId - Threat ID
   * @param {number} matchConfidence - Match confidence (0-100)
   * @param {string} notes - Optional notes
   * @returns {Promise<Object>} - Junction record
   */
  static async linkToThreat(vulnerabilityId, threatId, matchConfidence = 80, notes = null) {
    const query = `
      INSERT INTO threat_model.threat_vulnerabilities 
        (vulnerability_id, threat_id, match_confidence, notes)
      VALUES ($1, $2, $3, $4)
      ON CONFLICT (vulnerability_id, threat_id) 
      DO UPDATE SET match_confidence = $3, notes = $4
      RETURNING *
    `;
    
    const result = await db.query(query, [vulnerabilityId, threatId, matchConfidence, notes]);
    return result.rows[0];
  }
  
  /**
   * Unlink vulnerability from a threat
   * 
   * @param {string} vulnerabilityId - Vulnerability ID
   * @param {string} threatId - Threat ID
   * @returns {Promise<boolean>} - True if unlinked
   */
  static async unlinkFromThreat(vulnerabilityId, threatId) {
    const query = `
      DELETE FROM threat_model.threat_vulnerabilities 
      WHERE vulnerability_id = $1 AND threat_id = $2
    `;
    
    const result = await db.query(query, [vulnerabilityId, threatId]);
    return result.rowCount > 0;
  }
  
  /**
   * Import vulnerabilities from Rapid7 data
   * 
   * @param {Array} vulnerabilities - Array of Rapid7 vulnerability data
   * @param {string} scanHistoryId - ID of the scan history record
   * @returns {Promise<Object>} - Import results
   */
  static async importFromRapid7(vulnerabilities, scanHistoryId) {
    return db.transaction(async (client) => {
      const results = {
        created: 0,
        updated: 0,
        errors: 0,
        details: []
      };
      
      for (const vuln of vulnerabilities) {
        try {
          // Check if vulnerability already exists
          const existingQuery = `
            SELECT id FROM threat_model.vulnerabilities 
            WHERE external_id = $1 AND source = 'rapid7'
          `;
          const existingResult = await client.query(existingQuery, [vuln.id]);
          const existing = existingResult.rows[0];
          
          if (existing) {
            // Update existing vulnerability
            const updateQuery = `
              UPDATE threat_model.vulnerabilities
              SET 
                name = $1,
                description = $2,
                severity = $3,
                cvss_score = $4,
                cve_id = $5,
                remediation_steps = $6,
                last_checked = CURRENT_TIMESTAMP,
                updated_at = CURRENT_TIMESTAMP
              WHERE id = $7
              RETURNING *
            `;
            
            const updateValues = [
              vuln.title || 'Unknown',
              vuln.description,
              mapRapid7Severity(vuln.severity),
              vuln.cvss_score,
              vuln.cve || null,
              vuln.solution,
              existing.id
            ];
            
            await client.query(updateQuery, updateValues);
            results.updated++;
          } else {
            // Create new vulnerability
            const insertQuery = `
              INSERT INTO threat_model.vulnerabilities 
                (external_id, source, name, description, severity, 
                 cvss_score, cve_id, status, remediation_steps, discovered_at, last_checked)
              VALUES ($1, 'rapid7', $2, $3, $4, $5, $6, 'Open', $7, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
              RETURNING id
            `;
            
            const insertValues = [
              vuln.id,
              vuln.title || 'Unknown',
              vuln.description,
              mapRapid7Severity(vuln.severity),
              vuln.cvss_score,
              vuln.cve || null,
              vuln.solution
            ];
            
            const newVuln = await client.query(insertQuery, insertValues);
            results.created++;
            
            // Attempt to match to components based on asset information if available
            if (vuln.asset && vuln.asset.hostname && newVuln.rows[0].id) {
              await attemptComponentMatching(client, newVuln.rows[0].id, vuln.asset.hostname);
            }
          }
          
          results.details.push({
            external_id: vuln.id,
            status: existing ? 'updated' : 'created',
            name: vuln.title
          });
        } catch (error) {
          console.error('Error importing vulnerability:', error);
          results.errors++;
          results.details.push({
            external_id: vuln.id || 'unknown',
            status: 'error',
            error: error.message
          });
        }
      }
      
      // Update scan history with vulnerability counts
      if (scanHistoryId) {
        const updateScanQuery = `
          UPDATE threat_model.scan_history
          SET 
            vulnerabilities_found = $1,
            status = 'Completed',
            completed_at = CURRENT_TIMESTAMP
          WHERE id = $2
        `;
        
        await client.query(updateScanQuery, [results.created + results.updated, scanHistoryId]);
      }
      
      return results;
    });
  }
  
  /**
   * Get vulnerability statistics
   * 
   * @returns {Promise<Object>} - Vulnerability statistics
   */
  static async getStatistics() {
    const query = `
      SELECT 
        severity,
        COUNT(*)::integer as count,
        COUNT(CASE WHEN status = 'Open' THEN 1 END)::integer as open_count,
        COUNT(CASE WHEN status = 'Fixed' THEN 1 END)::integer as fixed_count,
        COUNT(CASE WHEN status = 'In Progress' THEN 1 END)::integer as in_progress_count
      FROM threat_model.vulnerabilities
      GROUP BY severity
      ORDER BY 
        CASE 
          WHEN severity = 'Critical' THEN 1
          WHEN severity = 'High' THEN 2
          WHEN severity = 'Medium' THEN 3
          WHEN severity = 'Low' THEN 4
          ELSE 5
        END
    `;
    
    const result = await db.query(query);
    
    // Format the results
    const statistics = {
      total: 0,
      open: 0,
      fixed: 0,
      in_progress: 0,
      by_severity: {}
    };
    
    result.rows.forEach(row => {
      statistics.total += row.count;
      statistics.open += row.open_count;
      statistics.fixed += row.fixed_count;
      statistics.in_progress += row.in_progress_count;
      
      statistics.by_severity[row.severity] = {
        total: row.count,
        open: row.open_count,
        fixed: row.fixed_count,
        in_progress: row.in_progress_count
      };
    });
    
    return statistics;
  }
}

/**
 * Map Rapid7 severity to our internal severity scale
 * 
 * @param {string|number} rapid7Severity - Severity from Rapid7
 * @returns {string} - Internal severity value
 */
function mapRapid7Severity(rapid7Severity) {
  // Rapid7 might use different scales in different APIs
  if (typeof rapid7Severity === 'string') {
    const severity = rapid7Severity.toLowerCase();
    if (severity.includes('critical')) return 'Critical';
    if (severity.includes('severe') || severity.includes('high')) return 'High';
    if (severity.includes('moderate') || severity.includes('medium')) return 'Medium';
    if (severity.includes('low')) return 'Low';
    return 'Info';
  } else if (typeof rapid7Severity === 'number') {
    // Assuming 0-10 scale
    if (rapid7Severity >= 9) return 'Critical';
    if (rapid7Severity >= 7) return 'High';
    if (rapid7Severity >= 4) return 'Medium';
    if (rapid7Severity >= 1) return 'Low';
    return 'Info';
  }
  
  return 'Info';
}

/**
 * Attempt to match a vulnerability to a component based on hostname
 * 
 * @param {Object} client - Database client
 * @param {string} vulnerabilityId - Vulnerability ID
 * @param {string} hostname - Hostname to match
 * @returns {Promise<boolean>} - True if matched
 */
async function attemptComponentMatching(client, vulnerabilityId, hostname) {
  try {
    // Look for components with matching hostname in their tags
    const query = `
      SELECT id FROM threat_model.components 
      WHERE $1 = ANY(tags) OR name ILIKE $2 OR description ILIKE $2
      LIMIT 1
    `;
    
    const result = await client.query(query, [hostname, `%${hostname}%`]);
    
    if (result.rows.length > 0) {
      const componentId = result.rows[0].id;
      
      // Update the vulnerability with the matched component
      const updateQuery = `
        UPDATE threat_model.vulnerabilities
        SET component_id = $1
        WHERE id = $2
      `;
      
      await client.query(updateQuery, [componentId, vulnerabilityId]);
      return true;
    }
    
    return false;
  } catch (error) {
    console.error('Error matching component:', error);
    return false;
  }
}

module.exports = Vulnerability;

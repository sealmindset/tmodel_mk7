// Route for the Vulnerability Dashboard UI page
const express = require('express');
const router = express.Router();
const rapid7Service = require('../services/rapid7Service');
const db = require('../db/db');
const { ensureAuthenticated } = require('../middleware/auth');

// Helper to get dashboard stats from DB (PostgreSQL)
async function getVulnerabilityStats(projectId = null) {
  let stats = {
    total: 0,
    open: 0,
    fixed: 0,
    in_progress: 0
  };
  
  try {
    let query = `SELECT status, COUNT(*) as count FROM threat_model.vulnerabilities`;
    const params = [];
    if (projectId) {
      query += ' WHERE project_id = $1';
      params.push(projectId);
    }
    query += ' GROUP BY status';
    const result = await db.query(query, params);
    for (const row of result.rows) {
      if (row.status === 'Open') stats.open = parseInt(row.count);
      else if (row.status === 'Fixed') stats.fixed = parseInt(row.count);
      else if (row.status === 'In Progress') stats.in_progress = parseInt(row.count);
      stats.total += parseInt(row.count);
    }
  } catch (error) {
    console.error('Error getting vulnerability stats:', error);
    // Return default empty stats
  }
  return stats;
}

// Helper to get scan stats
async function getScanStats(projectId = null) {
  let stats = { last_scan_date: null };
  
  try {
    let query = `SELECT MAX(created_at) as last_scan_date FROM threat_model.scan_history`;
    const params = [];
    if (projectId) {
      query += ' WHERE project_id = $1';
      params.push(projectId);
    }
    const result = await db.query(query, params);
    if (result.rows[0]) stats.last_scan_date = result.rows[0].last_scan_date;
  } catch (error) {
    console.error('Error getting scan stats:', error);
    // Return default empty stats
  }
  return stats;
}

// Helper to get top vulnerabilities
async function getTopVulnerabilities(limit = 5, projectId = null) {
  try {
    let query = `SELECT id, title, severity, cvss_score, status, asset_id FROM threat_model.vulnerabilities`;
    const params = [];
    if (projectId) {
      query += ' WHERE project_id = $1';
      params.push(projectId);
    }
    query += ' ORDER BY cvss_score DESC NULLS LAST LIMIT ' + limit;
    const result = await db.query(query, params);
    return result.rows;
  } catch (error) {
    console.error('Error getting top vulnerabilities:', error);
    return [];
  }
}

// Helper to get projects list (for filter dropdown)
async function getProjects() {
  try {
    const result = await db.query('SELECT id, name FROM threat_model.projects ORDER BY name ASC');
    return result.rows;
  } catch (error) {
    console.error('Error getting projects:', error);
    return [];
  }
}

// Helper to get the appropriate badge class for a vulnerability status
function getStatusBadge(status) {
  switch(status) {
    case 'Open': return 'danger';
    case 'In Progress': return 'warning';
    case 'Fixed': return 'success';
    default: return 'secondary';
  }
}

// GET /vulnerability-dashboard
router.get('/', ensureAuthenticated, async (req, res) => {
  try {
    const projectId = req.query.project_id || null;
    const [vulnerabilityStats, scanStats, topVulnerabilities, projects] = await Promise.all([
      getVulnerabilityStats(projectId),
      getScanStats(projectId),
      getTopVulnerabilities(5, projectId),
      getProjects()
    ]);

    // Check Rapid7 connection and last sync time from Redis
    const redis = require('../utils/redis').client;
    const [rapid7ApiUrl, rapid7ApiKey, lastSync] = await Promise.all([
      redis.get('settings:rapid7:api_url'),
      redis.get('settings:rapid7:api_key'),
      redis.get('rapid7:last_sync') // Get last sync timestamp if available
    ]);
    const rapid7Connected = !!(rapid7ApiUrl && rapid7ApiKey);

    res.render('vulnerability-dashboard', {
      vulnerabilityStats,
      scanStats,
      topVulnerabilities,
      projects,
      rapid7Connected,
      lastSync,
      rapid7Sites: [], // Default empty array until we fetch actual sites from Rapid7
      getStatusBadge // Pass the helper function to the template
    });
  } catch (error) {
    console.error('Error loading vulnerability dashboard:', error);
    
    // Even in error case, check Rapid7 connection status and last sync
    let rapid7Connected = false;
    let lastSync = null;
    try {
      const redis = require('../utils/redis').client;
      const [rapid7ApiUrl, rapid7ApiKey, lastSyncValue] = await Promise.all([
        redis.get('settings:rapid7:api_url'),
        redis.get('settings:rapid7:api_key'),
        redis.get('rapid7:last_sync')
      ]);
      rapid7Connected = !!(rapid7ApiUrl && rapid7ApiKey);
      lastSync = lastSyncValue;
    } catch (redisError) {
      console.error('Error checking Rapid7 connection status:', redisError);
    }
    
    res.status(500).render('vulnerability-dashboard', {
      vulnerabilityStats: {
        total: 0,
        open: 0,
        fixed: 0,
        in_progress: 0
      },
      scanStats: { last_scan_date: null },
      topVulnerabilities: [],
      projects: [],
      rapid7Connected,
      lastSync,
      rapid7Sites: [], // Empty array for sites
      message: { type: 'danger', text: 'Error loading dashboard: ' + error.message },
      getStatusBadge // Pass the helper function to the template
    });
  }
});

module.exports = router;
